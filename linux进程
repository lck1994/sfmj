system(const char*) 创建一个新进程 类似在 shell执行命令 返回127表示无效命令 返回-1 其它错误
exec        把当前进程替换
fork()  生成一个进程副本  返回0 代表子进程 -1错误 
fork生成的进程副本 将自己拷贝一份 父进程所拥有的资源 共享 例如设备 文件描述符
当调用fork时 应必须 wait/waitpid 否则子进程将处于僵死状态 调用时机 可以利用子进程结束 会 发送信号SIGCHLD会父进程
注:当多个子进程同时结束 发送多个SIGCHLD 信号不会排列 即父进程处理完一次 将此信号去除
这种情况 可以 循环当waitpid返回值>0

关系 父进程 结束 子进程 照常执行
子进程结束 则会 成为僵死进程 不会释放资源 直到 父进程结束
如果父进程 意外终止 则子进程将系统管理进程作为父进程

头文件 sys/wait.h
用wait(int*)函数 得到子进程的结束 参数获取 子进程如何退出的
waitpid(pid,int*,int options)等待指定的子进程 pid-1 则到任意一子进程 options WHOHANG则父进程不会挂起 此时返回0 表示没进程结束 -1表示错误 如无子进程
